Iterator<T, Out> :: T -> Option<(T, Out)>
Range<T: Add<T, T, T> + Eq<T, T, bool>> :: { first: T, last: T }

range_finished<T: Add<T, T, T> + Eq<T, T, bool>> :: Range<T> -> bool
range_finished = eq $ // This uses the fact that structs are actually just tuples in disguise

to_option<T> :: (bool, T) -> Option<T>
to_option true = Some $
to_option false  = None

iterator<T: Add<T, T, T> + Eq<T, T, bool>> :: Iterator<Range<T>, T>
iterator = apply $ range_finished ($)
	-> to_option $
	-> map_if $ Some (apply $ (map_field $ `first` (add $ 1)) (field $ `last`))

range<T: Add<T, T, T> + Eq<T, T, bool>> :: (T, T) -> Range<T>
range = $

_fold<I, Out, Acc: Iterator<I, Out>> :: (Option<(I, Out)>, Acc, (Acc, Out) -> Acc) -> Acc
_fold None = first $
_fold Some = flatten $ // (I, Out, Acc, (Acc, Out) -> Acc)
	-> reverse $ // ((Acc, Out) -> Acc, Acc, Out, I)
	-> apply $ (last $) ($) (first $) // (I, Acc, (Acc, Out) -> Acc)
	-> fold $

_fold_iterate<I, Out, Acc : Iterator<I, Out>> :: (I, Acc, (Acc, Out) -> Acc) -> Option<(I, Out)>
_fold_iterate = first $ -> iterator $

fold<I, Out, Acc: Iterator<I, Out>> :: (I, Acc, (Acc, Out) -> Acc) -> Acc
fold = apply $ _fold_iterate second last // (Option<(I, Out)>, Acc, (Acc, Out) -> Acc)
	-> _fold $

is_multiple<T : Mod<T, T, T>> :: (T, T) -> T
is_multiple = mod $
	-> eq 0

sum<T : Add<T, T, T>> :: Iterator<T> -> T
sum = fold $ 0 add

is_3_or_5 :: u32 -> bool
is_multiple_of_3_or_5 = apply $ (is_multiple $ 3) (is_multiple $ 5) -> or $

main :: () -> u32
main = range 0 1000 // from iterators example
	-> filter $ is_multiple_of_3_or_5
	-> sum $

Iterator<T, Out> :: T -> Option<(T, Out)>
Fibonacci :: (u32, u32)

fibonacci_next :: Fibonacci -> Fibonacci
fibonacci_next = apply $ last add

iterator :: Iterator<Fibonacci, u32>
iterator = apply $ fibonnaci_next first

fibonacci :: (u32, u32) -> Fibonacci
fibonacci = make $

even<T: Mod<T, T, T>> :: T -> bool
even = mod $ 2
	-> eq $ 0

main :: () -> u32
main = fibonnaaci 0 1
	-> take_while $ (lte 4_000_000)
	-> filter $ even
	-> sum $ // from euler 1

_if<T, Out> :: (bool, T -> Out, T) -> Option<Out>
_if true = $
_if false = None

if<T, Out> :: (T, bool, T -> Out) -> Option<Out>
if = apply $ second (apply $ last first) // Quick swizzle for pattern matching
	-> _if $

else<T> :: (Option<T>, () -> T)  -> T
else Some = $
else None = $

main :: () -> int
main = if () (eq 0 1) (4)
	-> else $ (2)

Option<T> :: [Some T, None]

unwrap<T> :: Option<T> -> T
unwrap Some = $
unwrap None = panic "Unwrapped None variant of Option"

Result<T, E> :: [Ok T, Err E]

unwrap<T, E> :: Result<T, E> -> T
unwrap Ok = $
unwrap Err = panic $

unwrap_err<T, E> :: Result<T, E> -> E
unwrap_err Ok = panic "Unwrapped Ok variant with unwrap_err"
unwrap_err Err = $
